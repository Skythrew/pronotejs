{"version":3,"sources":["../src/utils.ts","../src/more-itertools.ts","../src/itertools.ts","../src/custom.ts","../src/builtins.ts"],"sourcesContent":["import type { Primitive } from './types';\n\ntype CmpFn<T> = (a: T, b: T) => number;\n\nexport function keyToCmp<T>(keyFn: (item: T) => Primitive): CmpFn<T> {\n    return (a: T, b: T) => {\n        const ka = keyFn(a);\n        const kb = keyFn(b);\n        // istanbul ignore else -- @preserve\n        if (typeof ka === 'boolean' && typeof kb === 'boolean') {\n            return ka === kb ? 0 : !ka && kb ? -1 : 1;\n        } else if (typeof ka === 'number' && typeof kb === 'number') {\n            return ka - kb;\n        } else if (typeof ka === 'string' && typeof kb === 'string') {\n            return ka === kb ? 0 : ka < kb ? -1 : 1;\n        } else {\n            return -1;\n        }\n    };\n}\n\nexport function identityPredicate(x: unknown): boolean {\n    return !!x;\n}\n\nexport function numberIdentity(x: unknown): number {\n    // istanbul ignore if -- @preserve\n    if (typeof x !== 'number') {\n        throw new Error('Inputs must be numbers');\n    }\n    return x;\n}\n\nexport function primitiveIdentity<P extends Primitive>(x: P): P;\nexport function primitiveIdentity(x: unknown): Primitive;\nexport function primitiveIdentity(x: unknown): Primitive {\n    // istanbul ignore if -- @preserve\n    if (typeof x !== 'string' && typeof x !== 'number' && typeof x !== 'boolean') {\n        throw new Error('Please provide a key function that can establish object identity');\n    }\n    return x;\n}\n","import { iter, map } from './builtins';\nimport { izip, repeat } from './itertools';\nimport type { Predicate, Primitive } from './types';\nimport { primitiveIdentity } from './utils';\n\n/**\n * Break iterable into lists of length `size`:\n *\n *     [...chunked([1, 2, 3, 4, 5, 6], 3)]\n *     // [[1, 2, 3], [4, 5, 6]]\n *\n * If the length of iterable is not evenly divisible by `size`, the last returned\n * list will be shorter:\n *\n *     [...chunked([1, 2, 3, 4, 5, 6, 7, 8], 3)]\n *     // [[1, 2, 3], [4, 5, 6], [7, 8]]\n */\nexport function* chunked<T>(iterable: Iterable<T>, size: number): Iterable<T[]> {\n    if (size < 1) {\n        throw new Error(`Invalid chunk size: ${size}`);\n    }\n\n    const it = iter(iterable);\n    for (;;) {\n        const chunk = take(size, it);\n        if (chunk.length > 0) {\n            yield chunk;\n        }\n        if (chunk.length < size) {\n            return;\n        }\n    }\n}\n\n/**\n * Return an iterator flattening one level of nesting in a list of lists:\n *\n *     [...flatten([[0, 1], [2, 3]])]\n *     // [0, 1, 2, 3]\n *\n */\nexport function* flatten<T>(iterableOfIterables: Iterable<Iterable<T>>): Iterable<T> {\n    for (const iterable of iterableOfIterables) {\n        for (const item of iterable) {\n            yield item;\n        }\n    }\n}\n\n/**\n * Intersperse filler element `value` among the items in `iterable`.\n *\n *     >>> [...intersperse(-1, range(1, 5))]\n *     [1, -1, 2, -1, 3, -1, 4]\n *\n */\nexport function intersperse<T, V>(value: V, iterable: Iterable<T>): Iterable<T | V> {\n    const stream = flatten(izip(repeat(value), iterable));\n    take(1, stream); // eat away and discard the first value from the output\n    return stream;\n}\n\n/**\n * Returns an iterable containing only the first `n` elements of the given\n * iterable.\n */\nexport function* itake<T>(n: number, iterable: Iterable<T>): Iterable<T> {\n    const it = iter(iterable);\n    let count = n;\n    while (count-- > 0) {\n        const s = it.next();\n        if (!s.done) {\n            yield s.value;\n        } else {\n            // Iterable exhausted, quit early\n            return;\n        }\n    }\n}\n\n/**\n * Returns an iterator of paired items, overlapping, from the original.  When\n * the input iterable has a finite number of items `n`, the outputted iterable\n * will have `n - 1` items.\n *\n *     >>> pairwise([8, 2, 0, 7])\n *     [(8, 2), (2, 0), (0, 7)]\n *\n */\nexport function* pairwise<T>(iterable: Iterable<T>): Iterable<[T, T]> {\n    const it = iter(iterable);\n    const first = it.next();\n    if (first.done) {\n        return;\n    }\n\n    let r1: T = first.value;\n    for (const r2 of it) {\n        yield [r1, r2];\n        r1 = r2;\n    }\n}\n\n/**\n * Returns a 2-tuple of arrays.  Splits the elements in the input iterable into\n * either of the two arrays.  Will fully exhaust the input iterable.  The first\n * array contains all items that match the predicate, the second the rest:\n *\n *     >>> const isOdd = x => x % 2 !== 0;\n *     >>> const iterable = range(10);\n *     >>> const [odds, evens] = partition(iterable, isOdd);\n *     >>> odds\n *     [1, 3, 5, 7, 9]\n *     >>> evens\n *     [0, 2, 4, 6, 8]\n *\n */\nexport function partition<T, N extends T>(\n    iterable: Iterable<T>,\n    predicate: (item: T) => item is N\n): [N[], Exclude<T, N>[]];\nexport function partition<T>(iterable: Iterable<T>, predicate: Predicate<T>): [T[], T[]];\nexport function partition<T>(iterable: Iterable<T>, predicate: Predicate<T>): [T[], T[]] {\n    const good = [];\n    const bad = [];\n\n    for (const item of iterable) {\n        if (predicate(item)) {\n            good.push(item);\n        } else {\n            bad.push(item);\n        }\n    }\n\n    return [good, bad];\n}\n\n/**\n * Yields the next item from each iterable in turn, alternating between them.\n * Continues until all items are exhausted.\n *\n *     >>> [...roundrobin([1, 2, 3], [4], [5, 6, 7, 8])]\n *     [1, 4, 5, 2, 6, 3, 7, 8]\n */\nexport function* roundrobin<T>(...iters: Iterable<T>[]): Iterable<T> {\n    // We'll only keep lazy versions of the input iterables in here that we'll\n    // slowly going to exhaust.  Once an iterable is exhausted, it will be\n    // removed from this list.  Once the entire list is empty, this algorithm\n    // ends.\n    const iterables: Array<Iterator<T>> = map(iters, iter);\n\n    while (iterables.length > 0) {\n        let index = 0;\n        while (index < iterables.length) {\n            const it = iterables[index];\n            const result = it.next();\n\n            if (!result.done) {\n                yield result.value;\n                index++;\n            } else {\n                // This iterable is exhausted, make sure to remove it from the\n                // list of iterables.  We'll splice the array from under our\n                // feet, and NOT advancing the index counter.\n                iterables.splice(index, 1); // intentional side-effect!\n            }\n        }\n    }\n}\n\n/**\n * Yields the heads of all of the given iterables.  This is almost like\n * `roundrobin()`, except that the yielded outputs are grouped in to the\n * \"rounds\":\n *\n *     >>> [...heads([1, 2, 3], [4], [5, 6, 7, 8])]\n *     [[1, 4, 5], [2, 6], [3, 7], [8]]\n *\n * This is also different from `zipLongest()`, since the number of items in\n * each round can decrease over time, rather than being filled with a filler.\n */\nexport function* heads<T>(...iters: Array<Iterable<T>>): Iterable<T[]> {\n    // We'll only keep lazy versions of the input iterables in here that we'll\n    // slowly going to exhaust.  Once an iterable is exhausted, it will be\n    // removed from this list.  Once the entire list is empty, this algorithm\n    // ends.\n    const iterables: Array<Iterator<T>> = map(iters, iter);\n\n    while (iterables.length > 0) {\n        let index = 0;\n        const round = [];\n        while (index < iterables.length) {\n            const it = iterables[index];\n            const result = it.next();\n\n            if (!result.done) {\n                round.push(result.value);\n                index++;\n            } else {\n                // This iterable is exhausted, make sure to remove it from the\n                // list of iterables.  We'll splice the array from under our\n                // feet, and NOT advancing the index counter.\n                iterables.splice(index, 1); // intentional side-effect!\n            }\n        }\n        if (round.length > 0) {\n            yield round;\n        }\n    }\n}\n\n/**\n * Non-lazy version of itake().\n */\nexport function take<T>(n: number, iterable: Iterable<T>): T[] {\n    return Array.from(itake(n, iterable));\n}\n\n/**\n * Yield unique elements, preserving order.\n *\n *     >>> [...uniqueEverseen('AAAABBBCCDAABBB')]\n *     ['A', 'B', 'C', 'D']\n *     >>> [...uniqueEverseen('AbBCcAB', s => s.toLowerCase())]\n *     ['A', 'b', 'C']\n *\n */\nexport function* uniqueEverseen<T>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => Primitive = primitiveIdentity\n): Iterable<T> {\n    const seen = new Set();\n    for (const item of iterable) {\n        const key = keyFn(item);\n        if (!seen.has(key)) {\n            seen.add(key);\n            yield item;\n        }\n    }\n}\n\n/**\n * Yields elements in order, ignoring serial duplicates.\n *\n *     >>> [...uniqueJustseen('AAAABBBCCDAABBB')]\n *     ['A', 'B', 'C', 'D', 'A', 'B']\n *     >>> [...uniqueJustseen('AbBCcAB', s => s.toLowerCase())]\n *     ['A', 'b', 'C', 'A', 'B']\n *\n */\nexport function* uniqueJustseen<T>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => Primitive = primitiveIdentity\n): Iterable<T> {\n    let last = undefined;\n    for (const item of iterable) {\n        const key = keyFn(item);\n        if (key !== last) {\n            yield item;\n            last = key;\n        }\n    }\n}\n","import { enumerate, every, iter, range } from './builtins';\nimport { flatten } from './more-itertools';\nimport type { Predicate, Primitive } from './types';\nimport { primitiveIdentity } from './utils';\n\nconst SENTINEL = Symbol();\n\nfunction composeAnd(f1: (v1: number) => boolean, f2: (v2: number) => boolean): (v3: number) => boolean {\n    return (n: number) => f1(n) && f2(n);\n}\n\nfunction slicePredicate(start: number, stop: number | null, step: number) {\n    if (start < 0) throw new Error('start cannot be negative');\n    if (stop !== null && stop < 0) throw new Error('stop cannot be negative');\n    if (step <= 0) throw new Error('step cannot be negative');\n\n    let pred = (n: number) => n >= start;\n\n    if (stop !== null) {\n        const definedStop = stop;\n        pred = composeAnd(pred, (n: number) => n < definedStop);\n    }\n\n    if (step > 1) {\n        pred = composeAnd(pred, (n: number) => (n - start) % step === 0);\n    }\n\n    return pred;\n}\n\n/**\n * Returns an iterator that returns elements from the first iterable until it\n * is exhausted, then proceeds to the next iterable, until all of the iterables\n * are exhausted.  Used for treating consecutive sequences as a single\n * sequence.\n */\nexport function chain<T>(...iterables: Iterable<T>[]): Iterable<T> {\n    return flatten(iterables);\n}\n\n/**\n * Returns an iterator that counts up values starting with number `start`\n * (default 0), incrementing by `step`.  To decrement, use a negative step\n * number.\n */\nexport function* count(start = 0, step = 1): Iterable<number> {\n    let n = start;\n    for (;;) {\n        yield n;\n        n += step;\n    }\n}\n\n/**\n * Non-lazy version of icompress().\n */\nexport function compress<T>(data: Iterable<T>, selectors: Iterable<boolean>): T[] {\n    return Array.from(icompress(data, selectors));\n}\n\n/**\n * Returns an iterator producing elements from the iterable and saving a copy\n * of each.  When the iterable is exhausted, return elements from the saved\n * copy.  Repeats indefinitely.\n */\nexport function* cycle<T>(iterable: Iterable<T>): Iterable<T> {\n    const saved = [];\n    for (const element of iterable) {\n        yield element;\n        saved.push(element);\n    }\n\n    while (saved.length > 0) {\n        for (const element of saved) {\n            yield element;\n        }\n    }\n}\n\n/**\n * Returns an iterator that drops elements from the iterable as long as the\n * predicate is true; afterwards, returns every remaining element.  Note, the\n * iterator does not produce any output until the predicate first becomes\n * false.\n */\nexport function* dropwhile<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n    const it = iter(iterable);\n    for (const value of it) {\n        if (!predicate(value)) {\n            yield value;\n            break;\n        }\n    }\n\n    for (const value of it) {\n        yield value;\n    }\n}\n\nexport function* groupby<T, K extends Primitive>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => K = primitiveIdentity\n): Generator<[K, Generator<T, undefined>], undefined> {\n    const it = iter(iterable);\n\n    let currentValue: T;\n    let currentKey: K = SENTINEL as unknown as K;\n    //                           ^^^^^^^^^^^^^^^ Hack!\n    let targetKey: K = currentKey;\n\n    const grouper = function* grouper(tgtKey: K): Generator<T, undefined> {\n        while (currentKey === tgtKey) {\n            yield currentValue;\n\n            const nextVal = it.next();\n            if (nextVal.done) return;\n            currentValue = nextVal.value;\n            currentKey = keyFn(currentValue);\n        }\n    };\n\n    for (;;) {\n        while (currentKey === targetKey) {\n            const nextVal = it.next();\n            if (nextVal.done) {\n                currentKey = SENTINEL as unknown as K;\n                //                    ^^^^^^^^^^^^^^^ Hack!\n                return;\n            }\n            currentValue = nextVal.value;\n            currentKey = keyFn(currentValue);\n        }\n\n        targetKey = currentKey;\n        yield [currentKey, grouper(targetKey)];\n    }\n}\n\n/**\n * Returns an iterator that filters elements from data returning only those\n * that have a corresponding element in selectors that evaluates to `true`.\n * Stops when either the data or selectors iterables has been exhausted.\n */\nexport function* icompress<T>(data: Iterable<T>, selectors: Iterable<boolean>): Iterable<T> {\n    for (const [d, s] of izip(data, selectors)) {\n        if (s) {\n            yield d;\n        }\n    }\n}\n\n/**\n * Returns an iterator that filters elements from iterable returning only those\n * for which the predicate is true.\n */\nexport function ifilter<T, N extends T>(iterable: Iterable<T>, predicate: (item: T) => item is N): Iterable<N>;\nexport function ifilter<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T>;\nexport function* ifilter<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n    for (const value of iterable) {\n        if (predicate(value)) {\n            yield value;\n        }\n    }\n}\n\n/**\n * Returns an iterator that computes the given mapper function using arguments\n * from each of the iterables.\n */\nexport function* imap<T, V>(iterable: Iterable<T>, mapper: (item: T) => V): Iterable<V> {\n    for (const value of iterable) {\n        yield mapper(value);\n    }\n}\n\n/**\n * Returns an iterator that returns selected elements from the iterable.  If\n * `start` is non-zero, then elements from the iterable are skipped until start\n * is reached.  Then, elements are returned by making steps of `step` (defaults\n * to 1).  If set to higher than 1, items will be skipped.  If `stop` is\n * provided, then iteration continues until the iterator reached that index,\n * otherwise, the iterable will be fully exhausted.  `islice()` does not\n * support negative values for `start`, `stop`, or `step`.\n */\nexport function islice<T>(iterable: Iterable<T>, stop: number): Iterable<T>;\nexport function islice<T>(iterable: Iterable<T>, start: number, stop?: number | null, step?: number): Iterable<T>;\nexport function* islice<T>(\n    iterable: Iterable<T>,\n    stopOrStart: number,\n    possiblyStop?: number | null,\n    step = 1\n): Iterable<T> {\n    let start, stop;\n    if (possiblyStop !== undefined) {\n        // islice(iterable, start, stop[, step])\n        start = stopOrStart;\n        stop = possiblyStop;\n    } else {\n        // islice(iterable, stop)\n        start = 0;\n        stop = stopOrStart;\n    }\n\n    const pred = slicePredicate(start, stop, step);\n    for (const [i, value] of enumerate(iterable)) {\n        if (pred(i)) {\n            yield value;\n        }\n    }\n}\n\n/**\n * Returns an iterator that aggregates elements from each of the iterables.\n * Used for lock-step iteration over several iterables at a time.  When\n * iterating over two iterables, use `izip2`.  When iterating over three\n * iterables, use `izip3`, etc.  `izip` is an alias for `izip2`.\n */\nexport function* izip2<T1, T2>(xs: Iterable<T1>, ys: Iterable<T2>): Iterable<[T1, T2]> {\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        if (!x.done && !y.done) {\n            yield [x.value, y.value];\n        } else {\n            // One of the iterables exhausted\n            return;\n        }\n    }\n}\n\n/**\n * Like izip2, but for three input iterables.\n */\nexport function* izip3<T1, T2, T3>(xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Iterable<[T1, T2, T3]> {\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    const izs = iter(zs);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        const z = izs.next();\n        if (!x.done && !y.done && !z.done) {\n            yield [x.value, y.value, z.value];\n        } else {\n            // One of the iterables exhausted\n            return;\n        }\n    }\n}\n\nexport const izip = izip2;\n\n/**\n * Returns an iterator that aggregates elements from each of the iterables.  If\n * the iterables are of uneven length, missing values are filled-in with\n * fillvalue.  Iteration continues until the longest iterable is exhausted.\n */\nexport function* izipLongest2<T1, T2, D>(xs: Iterable<T1>, ys: Iterable<T2>, filler?: D): Iterable<[T1 | D, T2 | D]> {\n    const filler_ = filler as D;\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        if (x.done && y.done) {\n            // All iterables exhausted\n            return;\n        } else {\n            yield [!x.done ? x.value : filler_, !y.done ? y.value : filler_];\n        }\n    }\n}\n\n/**\n * See izipLongest2, but for three.\n */\nexport function* izipLongest3<T1, T2, T3, D = undefined>(\n    xs: Iterable<T1>,\n    ys: Iterable<T2>,\n    zs: Iterable<T3>,\n    filler?: D\n): Iterable<[T1 | D, T2 | D, T3 | D]> {\n    const filler_ = filler as D;\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    const izs = iter(zs);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        const z = izs.next();\n        if (x.done && y.done && z.done) {\n            // All iterables exhausted\n            return;\n        } else {\n            yield [!x.done ? x.value : filler_, !y.done ? y.value : filler_, !z.done ? z.value : filler_];\n        }\n    }\n}\n\n/**\n * Like the other izips (`izip`, `izip3`, etc), but generalized to take an\n * unlimited amount of input iterables.  Think `izip(*iterables)` in Python.\n *\n * **Note:** Due to Flow type system limitations, you can only \"generially\" zip\n * iterables with homogeneous types, so you cannot mix types like <A, B> like\n * you can with izip2().\n */\nexport function* izipMany<T>(...iters: Iterable<T>[]): Iterable<T[]> {\n    // Make them all iterables\n    const iterables = iters.map(iter);\n\n    for (;;) {\n        const heads: Array<IteratorResult<T, undefined>> = iterables.map((xs) => xs.next());\n        if (every(heads, (h) => !h.done)) {\n            yield heads.map((h) => h.value as T);\n        } else {\n            // One of the iterables exhausted\n            return;\n        }\n    }\n}\n\n/**\n * Return successive `r`-length permutations of elements in the iterable.\n *\n * If `r` is not specified, then `r` defaults to the length of the iterable and\n * all possible full-length permutations are generated.\n *\n * Permutations are emitted in lexicographic sort order.  So, if the input\n * iterable is sorted, the permutation tuples will be produced in sorted order.\n *\n * Elements are treated as unique based on their position, not on their value.\n * So if the input elements are unique, there will be no repeat values in each\n * permutation.\n */\nexport function* permutations<T>(iterable: Iterable<T>, r?: number): Iterable<T[]> {\n    const pool = Array.from(iterable);\n    const n = pool.length;\n    const x = r === undefined ? n : r;\n\n    if (x > n) {\n        return;\n    }\n\n    let indices: number[] = Array.from(range(n));\n    const cycles: number[] = Array.from(range(n, n - x, -1));\n    const poolgetter = (i: number) => pool[i];\n\n    yield indices.slice(0, x).map(poolgetter);\n\n    while (n > 0) {\n        let cleanExit = true;\n        for (const i of range(x - 1, -1, -1)) {\n            cycles[i] -= 1;\n            if (cycles[i] === 0) {\n                indices = indices\n                    .slice(0, i)\n                    .concat(indices.slice(i + 1))\n                    .concat(indices.slice(i, i + 1));\n                cycles[i] = n - i;\n            } else {\n                const j: number = cycles[i];\n\n                const [p, q] = [indices[indices.length - j], indices[i]];\n                indices[i] = p;\n                indices[indices.length - j] = q;\n                yield indices.slice(0, x).map(poolgetter);\n                cleanExit = false;\n                break;\n            }\n        }\n\n        if (cleanExit) {\n            return;\n        }\n    }\n}\n\n/**\n * Returns an iterator that produces values over and over again.  Runs\n * indefinitely unless the times argument is specified.\n */\nexport function* repeat<T>(thing: T, times?: number): Iterable<T> {\n    if (times === undefined) {\n        for (;;) {\n            yield thing;\n        }\n    } else {\n        for (const _ of range(times)) {\n            yield thing;\n        }\n    }\n}\n\n/**\n * Returns an iterator that produces elements from the iterable as long as the\n * predicate is true.\n */\nexport function* takewhile<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n    for (const value of iterable) {\n        if (!predicate(value)) return;\n        yield value;\n    }\n}\n\nexport function zipLongest2<T1, T2, D>(xs: Iterable<T1>, ys: Iterable<T2>, filler?: D): Array<[T1 | D, T2 | D]> {\n    return Array.from(izipLongest2(xs, ys, filler));\n}\n\nexport function zipLongest3<T1, T2, T3, D>(\n    xs: Iterable<T1>,\n    ys: Iterable<T2>,\n    zs: Iterable<T3>,\n    filler?: D\n): Array<[T1 | D, T2 | D, T3 | D]> {\n    return Array.from(izipLongest3(xs, ys, zs, filler));\n}\n\nexport const izipLongest = izipLongest2;\nexport const zipLongest = zipLongest2;\n\nexport function zipMany<T>(...iters: Iterable<T>[]): T[][] {\n    return Array.from(izipMany(...iters));\n}\n","import { ifilter, imap } from './itertools';\nimport { flatten } from './more-itertools';\nimport type { Predicate } from './types';\n\nfunction isNullish<T>(x: T): x is NonNullable<T> {\n    return x != null;\n}\n\nfunction isDefined<T>(x: T): boolean {\n    return x !== undefined;\n}\n\n/**\n * Returns an iterable, filtering out any \"nullish\" values from the iterable.\n *\n *     >>> compact([1, 2, undefined, 3, null])\n *     [1, 2, 3]\n *\n * For an eager version, @see compact().\n */\nexport function icompact<T>(iterable: Iterable<T | null | undefined>): Iterable<T> {\n    return ifilter(iterable, isNullish);\n}\n\n/**\n * Returns an array, filtering out any \"nullish\" values from the iterable.\n *\n *     >>> compact([1, 2, undefined, 3, null])\n *     [1, 2, 3]\n *\n * For a lazy version, @see icompact().\n */\nexport function compact<T>(iterable: Iterable<T | null | undefined>): T[] {\n    return Array.from(icompact(iterable));\n}\n\n/**\n * Removes all \"nullish\" values from the given object. Returns a new object.\n *\n *     >>> compactObject({ a: 1, b: undefined, c: 0, d: null })\n *     { a: 1, c: 0 }\n *\n */\nexport function compactObject<K extends string, V>(obj: Record<K, V | null | undefined>): Record<K, V> {\n    const result = {} as Record<K, V>;\n    for (const [key, value_] of Object.entries(obj)) {\n        const value = value_ as V | null | undefined;\n        if (value != null) {\n            result[key as K] = value;\n        }\n    }\n    return result;\n}\n\n/**\n * Returns the first item in the iterable for which the predicate holds, if\n * any. If no predicate is given, it will return the first value returned by\n * the iterable.\n */\nexport function find<T>(iterable: Iterable<T>, keyFn?: Predicate<T>): T | undefined {\n    if (keyFn === undefined) {\n        for (const value of iterable) {\n            return value;\n        }\n        return undefined;\n    } else {\n        for (const value of iterable) {\n            if (keyFn(value)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n}\n\n/**\n * Almost an alias of find(). There only is a difference if no key fn is\n * provided. In that case, `find()` will return the first item in the iterable,\n * whereas `first()` will return the first non-`undefined` value in the\n * iterable.\n */\nexport function first<T>(iterable: Iterable<T>, keyFn?: Predicate<T>): T | undefined {\n    return find(iterable, keyFn ?? isDefined);\n}\n\n/**\n * Returns 0 or more values for every value in the given iterable.\n * Technically, it's just calling map(), followed by flatten(), but it's a very\n * useful operation if you want to map over a structure, but not have a 1:1\n * input-output mapping.  Instead, if you want to potentially return 0 or more\n * values per input element, use flatmap():\n *\n * For example, to return all numbers `n` in the input iterable `n` times:\n *\n *     >>> const repeatN = n => repeat(n, n);\n *     >>> [...flatmap([0, 1, 2, 3, 4], repeatN)]\n *     [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]  // note: no 0\n *\n */\nexport function flatmap<T, S>(iterable: Iterable<T>, mapper: (item: T) => Iterable<S>): Iterable<S> {\n    return flatten(imap(iterable, mapper));\n}\n","import { find } from './custom';\nimport { count, ifilter, imap, izip, izip3, takewhile } from './itertools';\nimport type { Predicate, Primitive } from './types';\nimport { identityPredicate, keyToCmp, numberIdentity, primitiveIdentity } from './utils';\n\n/**\n * Returns true when all of the items in iterable are truthy.  An optional key\n * function can be used to define what truthiness means for this specific\n * collection.\n *\n * Examples:\n *\n *     all([])                           // => true\n *     all([0])                          // => false\n *     all([0, 1, 2])                    // => false\n *     all([1, 2, 3])                    // => true\n *\n * Examples with using a key function:\n *\n *     all([2, 4, 6], n => n % 2 === 0)  // => true\n *     all([2, 4, 5], n => n % 2 === 0)  // => false\n *\n */\nexport function every<T>(iterable: Iterable<T>, keyFn: Predicate<T> = identityPredicate): boolean {\n    for (const item of iterable) {\n        if (!keyFn(item)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Returns true when some of the items in iterable are truthy.  An optional key\n * function can be used to define what truthiness means for this specific\n * collection.\n *\n * Examples:\n *\n *     some([])                           // => false\n *     some([0])                          // => false\n *     some([0, 1, null, undefined])      // => true\n *\n * Examples with using a key function:\n *\n *     some([1, 4, 5], n => n % 2 === 0)  // => true\n *     some([{name: 'Bob'}, {name: 'Alice'}], person => person.name.startsWith('C'))  // => false\n *\n */\nexport function some<T>(iterable: Iterable<T>, keyFn: Predicate<T> = identityPredicate): boolean {\n    for (const item of iterable) {\n        if (keyFn(item)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Alias of `every()`.\n */\nexport const all = every;\n\n/**\n * Alias of `some()`.\n */\nexport const any = some;\n\n/**\n * Returns true when any of the items in the iterable are equal to the target object.\n *\n * Examples:\n *\n *     contains([], 'whatever')         // => false\n *     contains([3], 42)                // => false\n *     contains([3], 3)                 // => true\n *     contains([0, 1, 2], 2)           // => true\n *\n */\nexport function contains<T>(haystack: Iterable<T>, needle: T): boolean {\n    return some(haystack, (x) => x === needle);\n}\n\n/**\n * Returns an iterable of enumeration pairs.  Iterable must be a sequence, an\n * iterator, or some other object which supports iteration.  The elements\n * produced by returns a tuple containing a counter value (starting from 0 by\n * default) and the values obtained from iterating over given iterable.\n *\n * Example:\n *\n *     import { enumerate } from 'itertools';\n *\n *     console.log([...enumerate(['hello', 'world'])]);\n *     // [0, 'hello'], [1, 'world']]\n */\nexport function* enumerate<T>(iterable: Iterable<T>, start = 0): Iterable<[number, T]> {\n    let index: number = start;\n    for (const value of iterable) {\n        yield [index++, value];\n    }\n}\n\n/**\n * Non-lazy version of ifilter().\n */\nexport function filter<T, N extends T>(iterable: Iterable<T>, predicate: (item: T) => item is N): N[];\nexport function filter<T>(iterable: Iterable<T>, predicate: Predicate<T>): T[];\nexport function filter<T>(iterable: Iterable<T>, predicate: Predicate<T>): T[] {\n    return Array.from(ifilter(iterable, predicate));\n}\n\n/**\n * Returns an iterator object for the given iterable.  This can be used to\n * manually get an iterator for any iterable datastructure.  The purpose and\n * main use case of this function is to get a single iterator (a thing with\n * state, think of it as a \"cursor\") which can only be consumed once.\n */\nexport function iter<T>(iterable: Iterable<T>): IterableIterator<T> {\n    // class SelfIter implements IterableIterator<T> {\n    //     #iterator: Iterator<T>;\n    //     constructor(orig: Iterable<T>) {\n    //         this.#iterator = orig[Symbol.iterator]();\n    //     }\n    //     [Symbol.iterator]() {\n    //         return this;\n    //     }\n    //     next() {\n    //         return this.#iterator.next();\n    //     }\n    // }\n    // return new SelfIter(iterable);\n\n    return iterable[Symbol.iterator]() as IterableIterator<T>;\n    //                                 ^^^^^^^^^^^^^^^^^^^^^^ Not safe!\n}\n\n/**\n * Non-lazy version of imap().\n */\nexport function map<T, V>(iterable: Iterable<T>, mapper: (item: T) => V): V[] {\n    return Array.from(imap(iterable, mapper));\n}\n\n/**\n * Return the largest item in an iterable.  Only works for numbers, as ordering\n * is pretty poorly defined on any other data type in JS.  The optional `keyFn`\n * argument specifies a one-argument ordering function like that used for\n * sorted().\n *\n * If the iterable is empty, `undefined` is returned.\n *\n * If multiple items are maximal, the function returns either one of them, but\n * which one is not defined.\n */\nexport function max<T>(iterable: Iterable<T>, keyFn: (item: T) => number = numberIdentity): T | undefined {\n    return reduce2(iterable, (x, y) => (keyFn(x) > keyFn(y) ? x : y));\n}\n\n/**\n * Return the smallest item in an iterable.  Only works for numbers, as\n * ordering is pretty poorly defined on any other data type in JS.  The\n * optional `keyFn` argument specifies a one-argument ordering function like\n * that used for sorted().\n *\n * If the iterable is empty, `undefined` is returned.\n *\n * If multiple items are minimal, the function returns either one of them, but\n * which one is not defined.\n */\nexport function min<T>(iterable: Iterable<T>, keyFn: (item: T) => number = numberIdentity): T | undefined {\n    return reduce2(iterable, (x, y) => (keyFn(x) < keyFn(y) ? x : y));\n}\n\n/**\n * Internal helper for the range function\n */\nfunction range_(start: number, stop: number, step: number): Iterable<number> {\n    const counter = count(start, step);\n    const pred = step >= 0 ? (n: number) => n < stop : (n: number) => n > stop;\n    return takewhile(counter, pred);\n}\n\n/**\n * Returns an iterator producing all the numbers in the given range one by one,\n * starting from `start` (default 0), as long as `i < stop`, in increments of\n * `step` (default 1).\n *\n * `range(a)` is a convenient shorthand for `range(0, a)`.\n *\n * Various valid invocations:\n *\n *     range(5)           // [0, 1, 2, 3, 4]\n *     range(2, 5)        // [2, 3, 4]\n *     range(0, 5, 2)     // [0, 2, 4]\n *     range(5, 0, -1)    // [5, 4, 3, 2, 1]\n *     range(-3)          // []\n *\n * For a positive `step`, the iterator will keep producing values `n` as long\n * as the stop condition `n < stop` is satisfied.\n *\n * For a negative `step`, the iterator will keep producing values `n` as long\n * as the stop condition `n > stop` is satisfied.\n *\n * The produced range will be empty if the first value to produce already does\n * not meet the value constraint.\n */\n\nexport function range(stop: number): Iterable<number>;\nexport function range(start: number, stop: number, step?: number): Iterable<number>;\nexport function range(startOrStop: number, definitelyStop?: number, step = 1): Iterable<number> {\n    if (definitelyStop !== undefined) {\n        return range_(startOrStop /* as start */, definitelyStop, step);\n    } else {\n        return range_(0, startOrStop /* as stop */, step);\n    }\n}\n\n/**\n * Apply function of two arguments cumulatively to the items of sequence, from\n * left to right, so as to reduce the sequence to a single value.  For example:\n *\n *     reduce([1, 2, 3, 4, 5], (x, y) => x + y, 0)\n *\n * calculates\n *\n *     (((((0+1)+2)+3)+4)+5)\n *\n * The left argument, `x`, is the accumulated value and the right argument,\n * `y`, is the update value from the sequence.\n *\n * **Difference between `reduce()` and `reduce\\_()`**:  `reduce()` requires an\n * explicit initializer, whereas `reduce_()` will automatically use the first\n * item in the given iterable as the initializer.  When using `reduce()`, the\n * initializer value is placed before the items of the sequence in the\n * calculation, and serves as a default when the sequence is empty.  When using\n * `reduce_()`, and the given iterable is empty, then no default value can be\n * derived and `undefined` will be returned.\n */\nexport function reduce<T>(iterable: Iterable<T>, reducer: (agg: T, item: T, index: number) => T): T | undefined;\nexport function reduce<T, O>(iterable: Iterable<T>, reducer: (agg: O, item: T, index: number) => O, start: O): O;\nexport function reduce<T, O>(\n    iterable: Iterable<T>,\n    reducer: ((agg: T, item: T, index: number) => T) | ((agg: O, item: T, index: number) => O),\n    start?: O\n): O | (T | undefined) {\n    if (start === undefined) {\n        return reduce2(iterable, reducer as (agg: T, item: T, index: number) => T);\n    } else {\n        return reduce3(iterable, reducer as (agg: O, item: T, index: number) => O, start);\n    }\n}\n\nfunction reduce3<T, O>(iterable: Iterable<T>, reducer: (agg: O, item: T, index: number) => O, start: O): O {\n    let output = start;\n    let index = 0;\n    for (const item of iterable) {\n        output = reducer(output, item, index++);\n    }\n    return output;\n}\n\nfunction reduce2<T>(iterable: Iterable<T>, reducer: (agg: T, item: T, index: number) => T): T | undefined {\n    const it = iter(iterable);\n    const start = find(it);\n    if (start === undefined) {\n        return undefined;\n    } else {\n        return reduce3(it, reducer, start);\n    }\n}\n\n/**\n * Return a new sorted list from the items in iterable.\n *\n * Has two optional arguments:\n *\n * * `keyFn` specifies a function of one argument providing a primitive\n *   identity for each element in the iterable.  that will be used to compare.\n *   The default value is to use a default identity function that is only\n *   defined for primitive types.\n *\n * * `reverse` is a boolean value.  If `true`, then the list elements are\n *   sorted as if each comparison were reversed.\n */\nexport function sorted<T>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => Primitive = primitiveIdentity,\n    reverse = false\n): T[] {\n    const result = Array.from(iterable);\n    result.sort(keyToCmp(keyFn)); // sort in-place\n\n    if (reverse) {\n        result.reverse(); // reverse in-place\n    }\n\n    return result;\n}\n\n/**\n * Sums the items of an iterable from left to right and returns the total.  The\n * sum will defaults to 0 if the iterable is empty.\n */\nexport function sum(iterable: Iterable<number>): number {\n    return reduce(iterable, (x, y) => x + y, 0);\n}\n\n/**\n * See izip.\n */\nexport function zip<T1, T2>(xs: Iterable<T1>, ys: Iterable<T2>): Array<[T1, T2]> {\n    return Array.from(izip(xs, ys));\n}\n\n/**\n * See izip3.\n */\nexport function zip3<T1, T2, T3>(xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Array<[T1, T2, T3]> {\n    return Array.from(izip3(xs, ys, zs));\n}\n"],"mappings":"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","names":["keyToCmp","keyFn","a","b","ka","kb","identityPredicate","x","numberIdentity","primitiveIdentity","chunked","iterable","size","it","iter","chunk","take","flatten","iterableOfIterables","item","itake","n","iterable","it","iter","count","s","pairwise","first","r1","r2","partition","predicate","good","bad","item","roundrobin","iters","iterables","map","index","result","heads","round","take","uniqueEverseen","keyFn","primitiveIdentity","seen","key","uniqueJustseen","last","SENTINEL","composeAnd","f1","f2","n","slicePredicate","start","stop","step","pred","definedStop","chain","iterables","flatten","count","compress","data","selectors","icompress","cycle","iterable","saved","element","dropwhile","predicate","it","iter","value","groupby","keyFn","primitiveIdentity","currentValue","currentKey","targetKey","grouper","tgtKey","nextVal","d","s","izip","ifilter","imap","mapper","islice","stopOrStart","possiblyStop","i","enumerate","izip2","xs","ys","ixs","iys","x","y","izip3","zs","izs","z","izipLongest2","filler","filler_","izipMany","iters","iterables","iter","heads","xs","every","h","permutations","iterable","r","pool","x","indices","range","cycles","poolgetter","i","cleanExit","j","p","q","takewhile","iterable","predicate","value","zipLongest2","xs","ys","filler","izipLongest2","izipLongest","izipLongest2","zipLongest","zipLongest2","zipMany","iters","izipMany","isNullish","x","isDefined","icompact","iterable","ifilter","compact","compactObject","obj","result","key","value_","value","find","keyFn","first","flatmap","mapper","flatten","imap","every","iterable","keyFn","identityPredicate","item","some","all","any","contains","haystack","needle","x","enumerate","start","index","value","filter","predicate","ifilter","iter","map","mapper","imap","max","numberIdentity","reduce2","y","min","range_","stop","step","counter","count","pred","n","takewhile","range","startOrStop","definitelyStop","reduce","reducer","reduce3","output","it","find","sorted","primitiveIdentity","reverse","result","keyToCmp","sum","zip","xs","ys","izip","zip3","zs","izip3"]}