{"version":3,"sources":["../src/utils.ts","../src/more-itertools.ts","../src/itertools.ts","../src/custom.ts","../src/builtins.ts"],"names":["keyToCmp","keyFn","a","b","ka","kb","identityPredicate","x","numberIdentity","primitiveIdentity","chunked","iterable","size","it","iter","chunk","take","flatten","iterableOfIterables","item","itake","n","count","s","pairwise","first","r1","r2","partition","predicate","good","bad","roundrobin","iters","iterables","map","index","result","heads","round","uniqueEverseen","seen","key","uniqueJustseen","last","SENTINEL","composeAnd","f1","f2","slicePredicate","start","stop","step","pred","definedStop","chain","compress","data","selectors","icompress","cycle","saved","element","dropwhile","value","groupby","currentValue","currentKey","targetKey","grouper","tgtKey","nextVal","d","izip","ifilter","imap","mapper","islice","stopOrStart","possiblyStop","i","enumerate","izip2","xs","ys","ixs","iys","y","izip3","zs","izs","z","izipLongest2","filler","filler_","izipMany","every","h","permutations","r","pool","indices","range","cycles","poolgetter","cleanExit","j","p","q","takewhile","zipLongest2","izipLongest","zipLongest","zipMany","isNullish","isDefined","icompact","compact","compactObject","obj","value_","find","flatmap","some","all","any","contains","haystack","needle","filter","max","reduce2","min","range_","counter","startOrStop","definitelyStop","reduce","reducer","reduce3","output","sorted","reverse","sum","zip","zip3"],"mappings":"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","sourcesContent":["import type { Primitive } from './types';\n\ntype CmpFn<T> = (a: T, b: T) => number;\n\nexport function keyToCmp<T>(keyFn: (item: T) => Primitive): CmpFn<T> {\n    return (a: T, b: T) => {\n        const ka = keyFn(a);\n        const kb = keyFn(b);\n        // istanbul ignore else -- @preserve\n        if (typeof ka === 'boolean' && typeof kb === 'boolean') {\n            return ka === kb ? 0 : !ka && kb ? -1 : 1;\n        } else if (typeof ka === 'number' && typeof kb === 'number') {\n            return ka - kb;\n        } else if (typeof ka === 'string' && typeof kb === 'string') {\n            return ka === kb ? 0 : ka < kb ? -1 : 1;\n        } else {\n            return -1;\n        }\n    };\n}\n\nexport function identityPredicate(x: unknown): boolean {\n    return !!x;\n}\n\nexport function numberIdentity(x: unknown): number {\n    // istanbul ignore if -- @preserve\n    if (typeof x !== 'number') {\n        throw new Error('Inputs must be numbers');\n    }\n    return x;\n}\n\nexport function primitiveIdentity<P extends Primitive>(x: P): P;\nexport function primitiveIdentity(x: unknown): Primitive;\nexport function primitiveIdentity(x: unknown): Primitive {\n    // istanbul ignore if -- @preserve\n    if (typeof x !== 'string' && typeof x !== 'number' && typeof x !== 'boolean') {\n        throw new Error('Please provide a key function that can establish object identity');\n    }\n    return x;\n}\n","import { iter, map } from './builtins';\nimport { izip, repeat } from './itertools';\nimport type { Predicate, Primitive } from './types';\nimport { primitiveIdentity } from './utils';\n\n/**\n * Break iterable into lists of length `size`:\n *\n *     [...chunked([1, 2, 3, 4, 5, 6], 3)]\n *     // [[1, 2, 3], [4, 5, 6]]\n *\n * If the length of iterable is not evenly divisible by `size`, the last returned\n * list will be shorter:\n *\n *     [...chunked([1, 2, 3, 4, 5, 6, 7, 8], 3)]\n *     // [[1, 2, 3], [4, 5, 6], [7, 8]]\n */\nexport function* chunked<T>(iterable: Iterable<T>, size: number): Iterable<T[]> {\n    if (size < 1) {\n        throw new Error(`Invalid chunk size: ${size}`);\n    }\n\n    const it = iter(iterable);\n    for (;;) {\n        const chunk = take(size, it);\n        if (chunk.length > 0) {\n            yield chunk;\n        }\n        if (chunk.length < size) {\n            return;\n        }\n    }\n}\n\n/**\n * Return an iterator flattening one level of nesting in a list of lists:\n *\n *     [...flatten([[0, 1], [2, 3]])]\n *     // [0, 1, 2, 3]\n *\n */\nexport function* flatten<T>(iterableOfIterables: Iterable<Iterable<T>>): Iterable<T> {\n    for (const iterable of iterableOfIterables) {\n        for (const item of iterable) {\n            yield item;\n        }\n    }\n}\n\n/**\n * Intersperse filler element `value` among the items in `iterable`.\n *\n *     >>> [...intersperse(-1, range(1, 5))]\n *     [1, -1, 2, -1, 3, -1, 4]\n *\n */\nexport function intersperse<T, V>(value: V, iterable: Iterable<T>): Iterable<T | V> {\n    const stream = flatten(izip(repeat(value), iterable));\n    take(1, stream); // eat away and discard the first value from the output\n    return stream;\n}\n\n/**\n * Returns an iterable containing only the first `n` elements of the given\n * iterable.\n */\nexport function* itake<T>(n: number, iterable: Iterable<T>): Iterable<T> {\n    const it = iter(iterable);\n    let count = n;\n    while (count-- > 0) {\n        const s = it.next();\n        if (!s.done) {\n            yield s.value;\n        } else {\n            // Iterable exhausted, quit early\n            return;\n        }\n    }\n}\n\n/**\n * Returns an iterator of paired items, overlapping, from the original.  When\n * the input iterable has a finite number of items `n`, the outputted iterable\n * will have `n - 1` items.\n *\n *     >>> pairwise([8, 2, 0, 7])\n *     [(8, 2), (2, 0), (0, 7)]\n *\n */\nexport function* pairwise<T>(iterable: Iterable<T>): Iterable<[T, T]> {\n    const it = iter(iterable);\n    const first = it.next();\n    if (first.done) {\n        return;\n    }\n\n    let r1: T = first.value;\n    for (const r2 of it) {\n        yield [r1, r2];\n        r1 = r2;\n    }\n}\n\n/**\n * Returns a 2-tuple of arrays.  Splits the elements in the input iterable into\n * either of the two arrays.  Will fully exhaust the input iterable.  The first\n * array contains all items that match the predicate, the second the rest:\n *\n *     >>> const isOdd = x => x % 2 !== 0;\n *     >>> const iterable = range(10);\n *     >>> const [odds, evens] = partition(iterable, isOdd);\n *     >>> odds\n *     [1, 3, 5, 7, 9]\n *     >>> evens\n *     [0, 2, 4, 6, 8]\n *\n */\nexport function partition<T, N extends T>(\n    iterable: Iterable<T>,\n    predicate: (item: T) => item is N\n): [N[], Exclude<T, N>[]];\nexport function partition<T>(iterable: Iterable<T>, predicate: Predicate<T>): [T[], T[]];\nexport function partition<T>(iterable: Iterable<T>, predicate: Predicate<T>): [T[], T[]] {\n    const good = [];\n    const bad = [];\n\n    for (const item of iterable) {\n        if (predicate(item)) {\n            good.push(item);\n        } else {\n            bad.push(item);\n        }\n    }\n\n    return [good, bad];\n}\n\n/**\n * Yields the next item from each iterable in turn, alternating between them.\n * Continues until all items are exhausted.\n *\n *     >>> [...roundrobin([1, 2, 3], [4], [5, 6, 7, 8])]\n *     [1, 4, 5, 2, 6, 3, 7, 8]\n */\nexport function* roundrobin<T>(...iters: Iterable<T>[]): Iterable<T> {\n    // We'll only keep lazy versions of the input iterables in here that we'll\n    // slowly going to exhaust.  Once an iterable is exhausted, it will be\n    // removed from this list.  Once the entire list is empty, this algorithm\n    // ends.\n    const iterables: Array<Iterator<T>> = map(iters, iter);\n\n    while (iterables.length > 0) {\n        let index = 0;\n        while (index < iterables.length) {\n            const it = iterables[index];\n            const result = it.next();\n\n            if (!result.done) {\n                yield result.value;\n                index++;\n            } else {\n                // This iterable is exhausted, make sure to remove it from the\n                // list of iterables.  We'll splice the array from under our\n                // feet, and NOT advancing the index counter.\n                iterables.splice(index, 1); // intentional side-effect!\n            }\n        }\n    }\n}\n\n/**\n * Yields the heads of all of the given iterables.  This is almost like\n * `roundrobin()`, except that the yielded outputs are grouped in to the\n * \"rounds\":\n *\n *     >>> [...heads([1, 2, 3], [4], [5, 6, 7, 8])]\n *     [[1, 4, 5], [2, 6], [3, 7], [8]]\n *\n * This is also different from `zipLongest()`, since the number of items in\n * each round can decrease over time, rather than being filled with a filler.\n */\nexport function* heads<T>(...iters: Array<Iterable<T>>): Iterable<T[]> {\n    // We'll only keep lazy versions of the input iterables in here that we'll\n    // slowly going to exhaust.  Once an iterable is exhausted, it will be\n    // removed from this list.  Once the entire list is empty, this algorithm\n    // ends.\n    const iterables: Array<Iterator<T>> = map(iters, iter);\n\n    while (iterables.length > 0) {\n        let index = 0;\n        const round = [];\n        while (index < iterables.length) {\n            const it = iterables[index];\n            const result = it.next();\n\n            if (!result.done) {\n                round.push(result.value);\n                index++;\n            } else {\n                // This iterable is exhausted, make sure to remove it from the\n                // list of iterables.  We'll splice the array from under our\n                // feet, and NOT advancing the index counter.\n                iterables.splice(index, 1); // intentional side-effect!\n            }\n        }\n        if (round.length > 0) {\n            yield round;\n        }\n    }\n}\n\n/**\n * Non-lazy version of itake().\n */\nexport function take<T>(n: number, iterable: Iterable<T>): T[] {\n    return Array.from(itake(n, iterable));\n}\n\n/**\n * Yield unique elements, preserving order.\n *\n *     >>> [...uniqueEverseen('AAAABBBCCDAABBB')]\n *     ['A', 'B', 'C', 'D']\n *     >>> [...uniqueEverseen('AbBCcAB', s => s.toLowerCase())]\n *     ['A', 'b', 'C']\n *\n */\nexport function* uniqueEverseen<T>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => Primitive = primitiveIdentity\n): Iterable<T> {\n    const seen = new Set();\n    for (const item of iterable) {\n        const key = keyFn(item);\n        if (!seen.has(key)) {\n            seen.add(key);\n            yield item;\n        }\n    }\n}\n\n/**\n * Yields elements in order, ignoring serial duplicates.\n *\n *     >>> [...uniqueJustseen('AAAABBBCCDAABBB')]\n *     ['A', 'B', 'C', 'D', 'A', 'B']\n *     >>> [...uniqueJustseen('AbBCcAB', s => s.toLowerCase())]\n *     ['A', 'b', 'C', 'A', 'B']\n *\n */\nexport function* uniqueJustseen<T>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => Primitive = primitiveIdentity\n): Iterable<T> {\n    let last = undefined;\n    for (const item of iterable) {\n        const key = keyFn(item);\n        if (key !== last) {\n            yield item;\n            last = key;\n        }\n    }\n}\n","import { enumerate, every, iter, range } from './builtins';\nimport { flatten } from './more-itertools';\nimport type { Predicate, Primitive } from './types';\nimport { primitiveIdentity } from './utils';\n\nconst SENTINEL = Symbol();\n\nfunction composeAnd(f1: (v1: number) => boolean, f2: (v2: number) => boolean): (v3: number) => boolean {\n    return (n: number) => f1(n) && f2(n);\n}\n\nfunction slicePredicate(start: number, stop: number | null, step: number) {\n    if (start < 0) throw new Error('start cannot be negative');\n    if (stop !== null && stop < 0) throw new Error('stop cannot be negative');\n    if (step <= 0) throw new Error('step cannot be negative');\n\n    let pred = (n: number) => n >= start;\n\n    if (stop !== null) {\n        const definedStop = stop;\n        pred = composeAnd(pred, (n: number) => n < definedStop);\n    }\n\n    if (step > 1) {\n        pred = composeAnd(pred, (n: number) => (n - start) % step === 0);\n    }\n\n    return pred;\n}\n\n/**\n * Returns an iterator that returns elements from the first iterable until it\n * is exhausted, then proceeds to the next iterable, until all of the iterables\n * are exhausted.  Used for treating consecutive sequences as a single\n * sequence.\n */\nexport function chain<T>(...iterables: Iterable<T>[]): Iterable<T> {\n    return flatten(iterables);\n}\n\n/**\n * Returns an iterator that counts up values starting with number `start`\n * (default 0), incrementing by `step`.  To decrement, use a negative step\n * number.\n */\nexport function* count(start = 0, step = 1): Iterable<number> {\n    let n = start;\n    for (;;) {\n        yield n;\n        n += step;\n    }\n}\n\n/**\n * Non-lazy version of icompress().\n */\nexport function compress<T>(data: Iterable<T>, selectors: Iterable<boolean>): T[] {\n    return Array.from(icompress(data, selectors));\n}\n\n/**\n * Returns an iterator producing elements from the iterable and saving a copy\n * of each.  When the iterable is exhausted, return elements from the saved\n * copy.  Repeats indefinitely.\n */\nexport function* cycle<T>(iterable: Iterable<T>): Iterable<T> {\n    const saved = [];\n    for (const element of iterable) {\n        yield element;\n        saved.push(element);\n    }\n\n    while (saved.length > 0) {\n        for (const element of saved) {\n            yield element;\n        }\n    }\n}\n\n/**\n * Returns an iterator that drops elements from the iterable as long as the\n * predicate is true; afterwards, returns every remaining element.  Note, the\n * iterator does not produce any output until the predicate first becomes\n * false.\n */\nexport function* dropwhile<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n    const it = iter(iterable);\n    for (const value of it) {\n        if (!predicate(value)) {\n            yield value;\n            break;\n        }\n    }\n\n    for (const value of it) {\n        yield value;\n    }\n}\n\nexport function* groupby<T, K extends Primitive>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => K = primitiveIdentity\n): Generator<[K, Generator<T, undefined>], undefined> {\n    const it = iter(iterable);\n\n    let currentValue: T;\n    let currentKey: K = SENTINEL as unknown as K;\n    //                           ^^^^^^^^^^^^^^^ Hack!\n    let targetKey: K = currentKey;\n\n    const grouper = function* grouper(tgtKey: K): Generator<T, undefined> {\n        while (currentKey === tgtKey) {\n            yield currentValue;\n\n            const nextVal = it.next();\n            if (nextVal.done) return;\n            currentValue = nextVal.value;\n            currentKey = keyFn(currentValue);\n        }\n    };\n\n    for (;;) {\n        while (currentKey === targetKey) {\n            const nextVal = it.next();\n            if (nextVal.done) {\n                currentKey = SENTINEL as unknown as K;\n                //                    ^^^^^^^^^^^^^^^ Hack!\n                return;\n            }\n            currentValue = nextVal.value;\n            currentKey = keyFn(currentValue);\n        }\n\n        targetKey = currentKey;\n        yield [currentKey, grouper(targetKey)];\n    }\n}\n\n/**\n * Returns an iterator that filters elements from data returning only those\n * that have a corresponding element in selectors that evaluates to `true`.\n * Stops when either the data or selectors iterables has been exhausted.\n */\nexport function* icompress<T>(data: Iterable<T>, selectors: Iterable<boolean>): Iterable<T> {\n    for (const [d, s] of izip(data, selectors)) {\n        if (s) {\n            yield d;\n        }\n    }\n}\n\n/**\n * Returns an iterator that filters elements from iterable returning only those\n * for which the predicate is true.\n */\nexport function ifilter<T, N extends T>(iterable: Iterable<T>, predicate: (item: T) => item is N): Iterable<N>;\nexport function ifilter<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T>;\nexport function* ifilter<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n    for (const value of iterable) {\n        if (predicate(value)) {\n            yield value;\n        }\n    }\n}\n\n/**\n * Returns an iterator that computes the given mapper function using arguments\n * from each of the iterables.\n */\nexport function* imap<T, V>(iterable: Iterable<T>, mapper: (item: T) => V): Iterable<V> {\n    for (const value of iterable) {\n        yield mapper(value);\n    }\n}\n\n/**\n * Returns an iterator that returns selected elements from the iterable.  If\n * `start` is non-zero, then elements from the iterable are skipped until start\n * is reached.  Then, elements are returned by making steps of `step` (defaults\n * to 1).  If set to higher than 1, items will be skipped.  If `stop` is\n * provided, then iteration continues until the iterator reached that index,\n * otherwise, the iterable will be fully exhausted.  `islice()` does not\n * support negative values for `start`, `stop`, or `step`.\n */\nexport function islice<T>(iterable: Iterable<T>, stop: number): Iterable<T>;\nexport function islice<T>(iterable: Iterable<T>, start: number, stop?: number | null, step?: number): Iterable<T>;\nexport function* islice<T>(\n    iterable: Iterable<T>,\n    stopOrStart: number,\n    possiblyStop?: number | null,\n    step = 1\n): Iterable<T> {\n    let start, stop;\n    if (possiblyStop !== undefined) {\n        // islice(iterable, start, stop[, step])\n        start = stopOrStart;\n        stop = possiblyStop;\n    } else {\n        // islice(iterable, stop)\n        start = 0;\n        stop = stopOrStart;\n    }\n\n    const pred = slicePredicate(start, stop, step);\n    for (const [i, value] of enumerate(iterable)) {\n        if (pred(i)) {\n            yield value;\n        }\n    }\n}\n\n/**\n * Returns an iterator that aggregates elements from each of the iterables.\n * Used for lock-step iteration over several iterables at a time.  When\n * iterating over two iterables, use `izip2`.  When iterating over three\n * iterables, use `izip3`, etc.  `izip` is an alias for `izip2`.\n */\nexport function* izip2<T1, T2>(xs: Iterable<T1>, ys: Iterable<T2>): Iterable<[T1, T2]> {\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        if (!x.done && !y.done) {\n            yield [x.value, y.value];\n        } else {\n            // One of the iterables exhausted\n            return;\n        }\n    }\n}\n\n/**\n * Like izip2, but for three input iterables.\n */\nexport function* izip3<T1, T2, T3>(xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Iterable<[T1, T2, T3]> {\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    const izs = iter(zs);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        const z = izs.next();\n        if (!x.done && !y.done && !z.done) {\n            yield [x.value, y.value, z.value];\n        } else {\n            // One of the iterables exhausted\n            return;\n        }\n    }\n}\n\nexport const izip = izip2;\n\n/**\n * Returns an iterator that aggregates elements from each of the iterables.  If\n * the iterables are of uneven length, missing values are filled-in with\n * fillvalue.  Iteration continues until the longest iterable is exhausted.\n */\nexport function* izipLongest2<T1, T2, D>(xs: Iterable<T1>, ys: Iterable<T2>, filler?: D): Iterable<[T1 | D, T2 | D]> {\n    const filler_ = filler as D;\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        if (x.done && y.done) {\n            // All iterables exhausted\n            return;\n        } else {\n            yield [!x.done ? x.value : filler_, !y.done ? y.value : filler_];\n        }\n    }\n}\n\n/**\n * See izipLongest2, but for three.\n */\nexport function* izipLongest3<T1, T2, T3, D = undefined>(\n    xs: Iterable<T1>,\n    ys: Iterable<T2>,\n    zs: Iterable<T3>,\n    filler?: D\n): Iterable<[T1 | D, T2 | D, T3 | D]> {\n    const filler_ = filler as D;\n    const ixs = iter(xs);\n    const iys = iter(ys);\n    const izs = iter(zs);\n    for (;;) {\n        const x = ixs.next();\n        const y = iys.next();\n        const z = izs.next();\n        if (x.done && y.done && z.done) {\n            // All iterables exhausted\n            return;\n        } else {\n            yield [!x.done ? x.value : filler_, !y.done ? y.value : filler_, !z.done ? z.value : filler_];\n        }\n    }\n}\n\n/**\n * Like the other izips (`izip`, `izip3`, etc), but generalized to take an\n * unlimited amount of input iterables.  Think `izip(*iterables)` in Python.\n *\n * **Note:** Due to Flow type system limitations, you can only \"generially\" zip\n * iterables with homogeneous types, so you cannot mix types like <A, B> like\n * you can with izip2().\n */\nexport function* izipMany<T>(...iters: Iterable<T>[]): Iterable<T[]> {\n    // Make them all iterables\n    const iterables = iters.map(iter);\n\n    for (;;) {\n        const heads: Array<IteratorResult<T, undefined>> = iterables.map((xs) => xs.next());\n        if (every(heads, (h) => !h.done)) {\n            yield heads.map((h) => h.value as T);\n        } else {\n            // One of the iterables exhausted\n            return;\n        }\n    }\n}\n\n/**\n * Return successive `r`-length permutations of elements in the iterable.\n *\n * If `r` is not specified, then `r` defaults to the length of the iterable and\n * all possible full-length permutations are generated.\n *\n * Permutations are emitted in lexicographic sort order.  So, if the input\n * iterable is sorted, the permutation tuples will be produced in sorted order.\n *\n * Elements are treated as unique based on their position, not on their value.\n * So if the input elements are unique, there will be no repeat values in each\n * permutation.\n */\nexport function* permutations<T>(iterable: Iterable<T>, r?: number): Iterable<T[]> {\n    const pool = Array.from(iterable);\n    const n = pool.length;\n    const x = r === undefined ? n : r;\n\n    if (x > n) {\n        return;\n    }\n\n    let indices: number[] = Array.from(range(n));\n    const cycles: number[] = Array.from(range(n, n - x, -1));\n    const poolgetter = (i: number) => pool[i];\n\n    yield indices.slice(0, x).map(poolgetter);\n\n    while (n > 0) {\n        let cleanExit = true;\n        for (const i of range(x - 1, -1, -1)) {\n            cycles[i] -= 1;\n            if (cycles[i] === 0) {\n                indices = indices\n                    .slice(0, i)\n                    .concat(indices.slice(i + 1))\n                    .concat(indices.slice(i, i + 1));\n                cycles[i] = n - i;\n            } else {\n                const j: number = cycles[i];\n\n                const [p, q] = [indices[indices.length - j], indices[i]];\n                indices[i] = p;\n                indices[indices.length - j] = q;\n                yield indices.slice(0, x).map(poolgetter);\n                cleanExit = false;\n                break;\n            }\n        }\n\n        if (cleanExit) {\n            return;\n        }\n    }\n}\n\n/**\n * Returns an iterator that produces values over and over again.  Runs\n * indefinitely unless the times argument is specified.\n */\nexport function* repeat<T>(thing: T, times?: number): Iterable<T> {\n    if (times === undefined) {\n        for (;;) {\n            yield thing;\n        }\n    } else {\n        for (const _ of range(times)) {\n            yield thing;\n        }\n    }\n}\n\n/**\n * Returns an iterator that produces elements from the iterable as long as the\n * predicate is true.\n */\nexport function* takewhile<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n    for (const value of iterable) {\n        if (!predicate(value)) return;\n        yield value;\n    }\n}\n\nexport function zipLongest2<T1, T2, D>(xs: Iterable<T1>, ys: Iterable<T2>, filler?: D): Array<[T1 | D, T2 | D]> {\n    return Array.from(izipLongest2(xs, ys, filler));\n}\n\nexport function zipLongest3<T1, T2, T3, D>(\n    xs: Iterable<T1>,\n    ys: Iterable<T2>,\n    zs: Iterable<T3>,\n    filler?: D\n): Array<[T1 | D, T2 | D, T3 | D]> {\n    return Array.from(izipLongest3(xs, ys, zs, filler));\n}\n\nexport const izipLongest = izipLongest2;\nexport const zipLongest = zipLongest2;\n\nexport function zipMany<T>(...iters: Iterable<T>[]): T[][] {\n    return Array.from(izipMany(...iters));\n}\n","import { ifilter, imap } from './itertools';\nimport { flatten } from './more-itertools';\nimport type { Predicate } from './types';\n\nfunction isNullish<T>(x: T): x is NonNullable<T> {\n    return x != null;\n}\n\nfunction isDefined<T>(x: T): boolean {\n    return x !== undefined;\n}\n\n/**\n * Returns an iterable, filtering out any \"nullish\" values from the iterable.\n *\n *     >>> compact([1, 2, undefined, 3, null])\n *     [1, 2, 3]\n *\n * For an eager version, @see compact().\n */\nexport function icompact<T>(iterable: Iterable<T | null | undefined>): Iterable<T> {\n    return ifilter(iterable, isNullish);\n}\n\n/**\n * Returns an array, filtering out any \"nullish\" values from the iterable.\n *\n *     >>> compact([1, 2, undefined, 3, null])\n *     [1, 2, 3]\n *\n * For a lazy version, @see icompact().\n */\nexport function compact<T>(iterable: Iterable<T | null | undefined>): T[] {\n    return Array.from(icompact(iterable));\n}\n\n/**\n * Removes all \"nullish\" values from the given object. Returns a new object.\n *\n *     >>> compactObject({ a: 1, b: undefined, c: 0, d: null })\n *     { a: 1, c: 0 }\n *\n */\nexport function compactObject<K extends string, V>(obj: Record<K, V | null | undefined>): Record<K, V> {\n    const result = {} as Record<K, V>;\n    for (const [key, value_] of Object.entries(obj)) {\n        const value = value_ as V | null | undefined;\n        if (value != null) {\n            result[key as K] = value;\n        }\n    }\n    return result;\n}\n\n/**\n * Returns the first item in the iterable for which the predicate holds, if\n * any. If no predicate is given, it will return the first value returned by\n * the iterable.\n */\nexport function find<T>(iterable: Iterable<T>, keyFn?: Predicate<T>): T | undefined {\n    if (keyFn === undefined) {\n        for (const value of iterable) {\n            return value;\n        }\n        return undefined;\n    } else {\n        for (const value of iterable) {\n            if (keyFn(value)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n}\n\n/**\n * Almost an alias of find(). There only is a difference if no key fn is\n * provided. In that case, `find()` will return the first item in the iterable,\n * whereas `first()` will return the first non-`undefined` value in the\n * iterable.\n */\nexport function first<T>(iterable: Iterable<T>, keyFn?: Predicate<T>): T | undefined {\n    return find(iterable, keyFn ?? isDefined);\n}\n\n/**\n * Returns 0 or more values for every value in the given iterable.\n * Technically, it's just calling map(), followed by flatten(), but it's a very\n * useful operation if you want to map over a structure, but not have a 1:1\n * input-output mapping.  Instead, if you want to potentially return 0 or more\n * values per input element, use flatmap():\n *\n * For example, to return all numbers `n` in the input iterable `n` times:\n *\n *     >>> const repeatN = n => repeat(n, n);\n *     >>> [...flatmap([0, 1, 2, 3, 4], repeatN)]\n *     [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]  // note: no 0\n *\n */\nexport function flatmap<T, S>(iterable: Iterable<T>, mapper: (item: T) => Iterable<S>): Iterable<S> {\n    return flatten(imap(iterable, mapper));\n}\n","import { find } from './custom';\nimport { count, ifilter, imap, izip, izip3, takewhile } from './itertools';\nimport type { Predicate, Primitive } from './types';\nimport { identityPredicate, keyToCmp, numberIdentity, primitiveIdentity } from './utils';\n\n/**\n * Returns true when all of the items in iterable are truthy.  An optional key\n * function can be used to define what truthiness means for this specific\n * collection.\n *\n * Examples:\n *\n *     all([])                           // => true\n *     all([0])                          // => false\n *     all([0, 1, 2])                    // => false\n *     all([1, 2, 3])                    // => true\n *\n * Examples with using a key function:\n *\n *     all([2, 4, 6], n => n % 2 === 0)  // => true\n *     all([2, 4, 5], n => n % 2 === 0)  // => false\n *\n */\nexport function every<T>(iterable: Iterable<T>, keyFn: Predicate<T> = identityPredicate): boolean {\n    for (const item of iterable) {\n        if (!keyFn(item)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Returns true when some of the items in iterable are truthy.  An optional key\n * function can be used to define what truthiness means for this specific\n * collection.\n *\n * Examples:\n *\n *     some([])                           // => false\n *     some([0])                          // => false\n *     some([0, 1, null, undefined])      // => true\n *\n * Examples with using a key function:\n *\n *     some([1, 4, 5], n => n % 2 === 0)  // => true\n *     some([{name: 'Bob'}, {name: 'Alice'}], person => person.name.startsWith('C'))  // => false\n *\n */\nexport function some<T>(iterable: Iterable<T>, keyFn: Predicate<T> = identityPredicate): boolean {\n    for (const item of iterable) {\n        if (keyFn(item)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Alias of `every()`.\n */\nexport const all = every;\n\n/**\n * Alias of `some()`.\n */\nexport const any = some;\n\n/**\n * Returns true when any of the items in the iterable are equal to the target object.\n *\n * Examples:\n *\n *     contains([], 'whatever')         // => false\n *     contains([3], 42)                // => false\n *     contains([3], 3)                 // => true\n *     contains([0, 1, 2], 2)           // => true\n *\n */\nexport function contains<T>(haystack: Iterable<T>, needle: T): boolean {\n    return some(haystack, (x) => x === needle);\n}\n\n/**\n * Returns an iterable of enumeration pairs.  Iterable must be a sequence, an\n * iterator, or some other object which supports iteration.  The elements\n * produced by returns a tuple containing a counter value (starting from 0 by\n * default) and the values obtained from iterating over given iterable.\n *\n * Example:\n *\n *     import { enumerate } from 'itertools';\n *\n *     console.log([...enumerate(['hello', 'world'])]);\n *     // [0, 'hello'], [1, 'world']]\n */\nexport function* enumerate<T>(iterable: Iterable<T>, start = 0): Iterable<[number, T]> {\n    let index: number = start;\n    for (const value of iterable) {\n        yield [index++, value];\n    }\n}\n\n/**\n * Non-lazy version of ifilter().\n */\nexport function filter<T, N extends T>(iterable: Iterable<T>, predicate: (item: T) => item is N): N[];\nexport function filter<T>(iterable: Iterable<T>, predicate: Predicate<T>): T[];\nexport function filter<T>(iterable: Iterable<T>, predicate: Predicate<T>): T[] {\n    return Array.from(ifilter(iterable, predicate));\n}\n\n/**\n * Returns an iterator object for the given iterable.  This can be used to\n * manually get an iterator for any iterable datastructure.  The purpose and\n * main use case of this function is to get a single iterator (a thing with\n * state, think of it as a \"cursor\") which can only be consumed once.\n */\nexport function iter<T>(iterable: Iterable<T>): IterableIterator<T> {\n    // class SelfIter implements IterableIterator<T> {\n    //     #iterator: Iterator<T>;\n    //     constructor(orig: Iterable<T>) {\n    //         this.#iterator = orig[Symbol.iterator]();\n    //     }\n    //     [Symbol.iterator]() {\n    //         return this;\n    //     }\n    //     next() {\n    //         return this.#iterator.next();\n    //     }\n    // }\n    // return new SelfIter(iterable);\n\n    return iterable[Symbol.iterator]() as IterableIterator<T>;\n    //                                 ^^^^^^^^^^^^^^^^^^^^^^ Not safe!\n}\n\n/**\n * Non-lazy version of imap().\n */\nexport function map<T, V>(iterable: Iterable<T>, mapper: (item: T) => V): V[] {\n    return Array.from(imap(iterable, mapper));\n}\n\n/**\n * Return the largest item in an iterable.  Only works for numbers, as ordering\n * is pretty poorly defined on any other data type in JS.  The optional `keyFn`\n * argument specifies a one-argument ordering function like that used for\n * sorted().\n *\n * If the iterable is empty, `undefined` is returned.\n *\n * If multiple items are maximal, the function returns either one of them, but\n * which one is not defined.\n */\nexport function max<T>(iterable: Iterable<T>, keyFn: (item: T) => number = numberIdentity): T | undefined {\n    return reduce2(iterable, (x, y) => (keyFn(x) > keyFn(y) ? x : y));\n}\n\n/**\n * Return the smallest item in an iterable.  Only works for numbers, as\n * ordering is pretty poorly defined on any other data type in JS.  The\n * optional `keyFn` argument specifies a one-argument ordering function like\n * that used for sorted().\n *\n * If the iterable is empty, `undefined` is returned.\n *\n * If multiple items are minimal, the function returns either one of them, but\n * which one is not defined.\n */\nexport function min<T>(iterable: Iterable<T>, keyFn: (item: T) => number = numberIdentity): T | undefined {\n    return reduce2(iterable, (x, y) => (keyFn(x) < keyFn(y) ? x : y));\n}\n\n/**\n * Internal helper for the range function\n */\nfunction range_(start: number, stop: number, step: number): Iterable<number> {\n    const counter = count(start, step);\n    const pred = step >= 0 ? (n: number) => n < stop : (n: number) => n > stop;\n    return takewhile(counter, pred);\n}\n\n/**\n * Returns an iterator producing all the numbers in the given range one by one,\n * starting from `start` (default 0), as long as `i < stop`, in increments of\n * `step` (default 1).\n *\n * `range(a)` is a convenient shorthand for `range(0, a)`.\n *\n * Various valid invocations:\n *\n *     range(5)           // [0, 1, 2, 3, 4]\n *     range(2, 5)        // [2, 3, 4]\n *     range(0, 5, 2)     // [0, 2, 4]\n *     range(5, 0, -1)    // [5, 4, 3, 2, 1]\n *     range(-3)          // []\n *\n * For a positive `step`, the iterator will keep producing values `n` as long\n * as the stop condition `n < stop` is satisfied.\n *\n * For a negative `step`, the iterator will keep producing values `n` as long\n * as the stop condition `n > stop` is satisfied.\n *\n * The produced range will be empty if the first value to produce already does\n * not meet the value constraint.\n */\n\nexport function range(stop: number): Iterable<number>;\nexport function range(start: number, stop: number, step?: number): Iterable<number>;\nexport function range(startOrStop: number, definitelyStop?: number, step = 1): Iterable<number> {\n    if (definitelyStop !== undefined) {\n        return range_(startOrStop /* as start */, definitelyStop, step);\n    } else {\n        return range_(0, startOrStop /* as stop */, step);\n    }\n}\n\n/**\n * Apply function of two arguments cumulatively to the items of sequence, from\n * left to right, so as to reduce the sequence to a single value.  For example:\n *\n *     reduce([1, 2, 3, 4, 5], (x, y) => x + y, 0)\n *\n * calculates\n *\n *     (((((0+1)+2)+3)+4)+5)\n *\n * The left argument, `x`, is the accumulated value and the right argument,\n * `y`, is the update value from the sequence.\n *\n * **Difference between `reduce()` and `reduce\\_()`**:  `reduce()` requires an\n * explicit initializer, whereas `reduce_()` will automatically use the first\n * item in the given iterable as the initializer.  When using `reduce()`, the\n * initializer value is placed before the items of the sequence in the\n * calculation, and serves as a default when the sequence is empty.  When using\n * `reduce_()`, and the given iterable is empty, then no default value can be\n * derived and `undefined` will be returned.\n */\nexport function reduce<T>(iterable: Iterable<T>, reducer: (agg: T, item: T, index: number) => T): T | undefined;\nexport function reduce<T, O>(iterable: Iterable<T>, reducer: (agg: O, item: T, index: number) => O, start: O): O;\nexport function reduce<T, O>(\n    iterable: Iterable<T>,\n    reducer: ((agg: T, item: T, index: number) => T) | ((agg: O, item: T, index: number) => O),\n    start?: O\n): O | (T | undefined) {\n    if (start === undefined) {\n        return reduce2(iterable, reducer as (agg: T, item: T, index: number) => T);\n    } else {\n        return reduce3(iterable, reducer as (agg: O, item: T, index: number) => O, start);\n    }\n}\n\nfunction reduce3<T, O>(iterable: Iterable<T>, reducer: (agg: O, item: T, index: number) => O, start: O): O {\n    let output = start;\n    let index = 0;\n    for (const item of iterable) {\n        output = reducer(output, item, index++);\n    }\n    return output;\n}\n\nfunction reduce2<T>(iterable: Iterable<T>, reducer: (agg: T, item: T, index: number) => T): T | undefined {\n    const it = iter(iterable);\n    const start = find(it);\n    if (start === undefined) {\n        return undefined;\n    } else {\n        return reduce3(it, reducer, start);\n    }\n}\n\n/**\n * Return a new sorted list from the items in iterable.\n *\n * Has two optional arguments:\n *\n * * `keyFn` specifies a function of one argument providing a primitive\n *   identity for each element in the iterable.  that will be used to compare.\n *   The default value is to use a default identity function that is only\n *   defined for primitive types.\n *\n * * `reverse` is a boolean value.  If `true`, then the list elements are\n *   sorted as if each comparison were reversed.\n */\nexport function sorted<T>(\n    iterable: Iterable<T>,\n    keyFn: (item: T) => Primitive = primitiveIdentity,\n    reverse = false\n): T[] {\n    const result = Array.from(iterable);\n    result.sort(keyToCmp(keyFn)); // sort in-place\n\n    if (reverse) {\n        result.reverse(); // reverse in-place\n    }\n\n    return result;\n}\n\n/**\n * Sums the items of an iterable from left to right and returns the total.  The\n * sum will defaults to 0 if the iterable is empty.\n */\nexport function sum(iterable: Iterable<number>): number {\n    return reduce(iterable, (x, y) => x + y, 0);\n}\n\n/**\n * See izip.\n */\nexport function zip<T1, T2>(xs: Iterable<T1>, ys: Iterable<T2>): Array<[T1, T2]> {\n    return Array.from(izip(xs, ys));\n}\n\n/**\n * See izip3.\n */\nexport function zip3<T1, T2, T3>(xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Array<[T1, T2, T3]> {\n    return Array.from(izip3(xs, ys, zs));\n}\n"]}